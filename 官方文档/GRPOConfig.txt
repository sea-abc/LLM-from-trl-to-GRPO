class trl.GRPOConfig
( output_dir: typing.Optional[str] = Noneoverwrite_output_dir: bool = Falsedo_train: bool = Falsedo_eval: bool = Falsedo_predict: bool = Falseeval_strategy: typing.Union[transformers.trainer_utils.IntervalStrategy, str] = 'no'prediction_loss_only: bool = Falseper_device_train_batch_size: int = 8per_device_eval_batch_size: int = 8per_gpu_train_batch_size: typing.Optional[int] = Noneper_gpu_eval_batch_size: typing.Optional[int] = Nonegradient_accumulation_steps: int = 1eval_accumulation_steps: typing.Optional[int] = Noneeval_delay: float = 0torch_empty_cache_steps: typing.Optional[int] = Nonelearning_rate: float = 1e-06weight_decay: float = 0.0adam_beta1: float = 0.9adam_beta2: float = 0.999adam_epsilon: float = 1e-08max_grad_norm: float = 1.0num_train_epochs: float = 3.0max_steps: int = -1lr_scheduler_type: typing.Union[transformers.trainer_utils.SchedulerType, str] = 'linear'lr_scheduler_kwargs: dict | str | None = Nonewarmup_ratio: float = 0.0warmup_steps: int = 0log_level: str = 'passive'log_level_replica: str = 'warning'log_on_each_node: bool = Truelogging_dir: typing.Optional[str] = Nonelogging_strategy: typing.Union[transformers.trainer_utils.IntervalStrategy, str] = 'steps'logging_first_step: bool = Falselogging_steps: float = 10logging_nan_inf_filter: bool = Truesave_strategy: typing.Union[transformers.trainer_utils.SaveStrategy, str] = 'steps'save_steps: float = 500save_total_limit: typing.Optional[int] = Nonesave_safetensors: bool = Truesave_on_each_node: bool = Falsesave_only_model: bool = Falserestore_callback_states_from_checkpoint: bool = Falseno_cuda: bool = Falseuse_cpu: bool = Falseuse_mps_device: bool = Falseseed: int = 42data_seed: typing.Optional[int] = Nonejit_mode_eval: bool = Falsebf16: bool | None = Nonefp16: bool = Falsefp16_opt_level: str = 'O1'half_precision_backend: str = 'auto'bf16_full_eval: bool = Falsefp16_full_eval: bool = Falsetf32: typing.Optional[bool] = Nonelocal_rank: int = -1ddp_backend: typing.Optional[str] = Nonetpu_num_cores: typing.Optional[int] = Nonetpu_metrics_debug: bool = Falsedebug: typing.Union[str, list[transformers.debug_utils.DebugOption]] = ''dataloader_drop_last: bool = Falseeval_steps: typing.Optional[float] = Nonedataloader_num_workers: int = 0dataloader_prefetch_factor: typing.Optional[int] = Nonepast_index: int = -1run_name: typing.Optional[str] = Nonedisable_tqdm: typing.Optional[bool] = Noneremove_unused_columns: bool | None = Falselabel_names: typing.Optional[list[str]] = Noneload_best_model_at_end: bool = Falsemetric_for_best_model: typing.Optional[str] = Nonegreater_is_better: typing.Optional[bool] = Noneignore_data_skip: bool = Falsefsdp: typing.Union[list[transformers.trainer_utils.FSDPOption], str, NoneType] = Nonefsdp_min_num_params: int = 0fsdp_config: typing.Union[dict[str, typing.Any], str, NoneType] = Nonefsdp_transformer_layer_cls_to_wrap: typing.Optional[str] = Noneaccelerator_config: typing.Union[dict, str, NoneType] = Noneparallelism_config: typing.Optional[accelerate.parallelism_config.ParallelismConfig] = Nonedeepspeed: typing.Union[dict, str, NoneType] = Nonelabel_smoothing_factor: float = 0.0optim: typing.Union[transformers.training_args.OptimizerNames, str] = 'adamw_torch_fused'optim_args: typing.Optional[str] = Noneadafactor: bool = Falsegroup_by_length: bool = Falselength_column_name: str = 'length'report_to: typing.Union[NoneType, str, list[str]] = Noneproject: str = 'huggingface'trackio_space_id: typing.Optional[str] = 'trackio'ddp_find_unused_parameters: typing.Optional[bool] = Noneddp_bucket_cap_mb: typing.Optional[int] = Noneddp_broadcast_buffers: typing.Optional[bool] = Nonedataloader_pin_memory: bool = Truedataloader_persistent_workers: bool = Falseskip_memory_metrics: bool = Trueuse_legacy_prediction_loop: bool = Falsepush_to_hub: bool = Falseresume_from_checkpoint: typing.Optional[str] = Nonehub_model_id: typing.Optional[str] = Nonehub_strategy: typing.Union[transformers.trainer_utils.HubStrategy, str] = 'every_save'hub_token: typing.Optional[str] = Nonehub_private_repo: typing.Optional[bool] = Nonehub_always_push: bool = Falsehub_revision: typing.Optional[str] = Nonegradient_checkpointing: bool = Truegradient_checkpointing_kwargs: typing.Union[dict[str, typing.Any], str, NoneType] = Noneinclude_inputs_for_metrics: bool = Falseinclude_for_metrics: list = <factory>eval_do_concat_batches: bool = Truefp16_backend: str = 'auto'push_to_hub_model_id: typing.Optional[str] = Nonepush_to_hub_organization: typing.Optional[str] = Nonepush_to_hub_token: typing.Optional[str] = Nonemp_parameters: str = ''auto_find_batch_size: bool = Falsefull_determinism: bool = Falsetorchdynamo: typing.Optional[str] = Noneray_scope: typing.Optional[str] = 'last'ddp_timeout: int = 1800torch_compile: bool = Falsetorch_compile_backend: typing.Optional[str] = Nonetorch_compile_mode: typing.Optional[str] = Noneinclude_tokens_per_second: bool = Falseinclude_num_input_tokens_seen: typing.Union[str, bool] = Falseneftune_noise_alpha: typing.Optional[float] = Noneoptim_target_modules: typing.Union[NoneType, str, list[str]] = Nonebatch_eval_metrics: bool = Falseeval_on_start: bool = Falseuse_liger_kernel: bool = Falseliger_kernel_config: typing.Optional[dict[str, bool]] = Noneeval_use_gather_object: bool = Falseaverage_tokens_across_devices: bool = Truemodel_init_kwargs: dict | str | None = Nonedisable_dropout: bool = Falsecast_lm_head_to_fp32: bool = Falsenum_generations: int | None = 8num_generations_eval: int | None = Nonemax_completion_length: int | None = 256ds3_gather_for_generation: bool = Trueshuffle_dataset: bool | None = Truegeneration_batch_size: int | None = Nonesteps_per_generation: int | None = Nonetemperature: float = 1.0top_p: float = 1.0top_k: int | None = Nonemin_p: float | None = Nonegeneration_kwargs: dict | None = Nonechat_template_kwargs: dict | None = Nonerepetition_penalty: float = 1.0use_transformers_paged: bool = Falsecache_implementation: str | None = Noneuse_vllm: bool = Falsevllm_mode: str = 'server'vllm_model_impl: str = 'vllm'vllm_enable_sleep_mode: bool = Falsevllm_guided_decoding_regex: str | None = Nonevllm_server_base_url: str | None = Nonevllm_server_host: str = '0.0.0.0'vllm_server_port: int = 8000vllm_server_timeout: float = 240.0vllm_gpu_memory_utilization: float = 0.3vllm_max_model_length: int | None = Nonevllm_tensor_parallel_size: int = 1beta: float = 0.0num_iterations: int = 1epsilon: float = 0.2delta: float | None = Noneepsilon_high: float | None = Nonesapo_temperature_neg: float = 1.05sapo_temperature_pos: float = 1.0importance_sampling_level: str = 'token'reward_weights: list[float] | None = Nonescale_rewards: str = 'group'loss_type: str = 'dapo'mask_truncated_completions: bool = Falsesync_ref_model: bool = Falseref_model_mixup_alpha: float = 0.6ref_model_sync_steps: int = 512top_entropy_quantile: float = 1.0use_liger_loss: bool = Nonevllm_importance_sampling_correction: bool = Truevllm_importance_sampling_mode: str = 'sequence_mask'vllm_importance_sampling_cap: float = 3.0use_bias_correction_kl: bool = Falselog_completions: bool = Falsenum_completions_to_print: int | None = Nonelog_unique_prompts: bool = Falsemax_prompt_length: int | None = Nonewandb_log_unique_prompts: bool | None = None )
Parameters that control the model and reference model

model_init_kwargs (str, dict[str, Any], optional) — Keyword arguments for from_pretrained, used when the model argument of the GRPOTrainer is provided as a string.
disable_dropout (bool, optional, defaults to False) — Whether to disable dropout in the model. This is useful for training with a reference model, as it prevents the model from generating different logprobs for the same input.
cast_lm_head_to_fp32 (bool, optional, defaults to False) — Whether to cast the language modeling head of the policy and reference models to float32. As recommended by the ScaleRL recipe. This flag is only supported when the model has untied word embedding and language modeling head layers i.e. tie_word_embeddings in the model config is False.
Parameters that control the data preprocessing

remove_unused_columns (bool, optional, defaults to False) — Whether to only keep the column "prompt" in the dataset. If you use a custom reward function that requires any column other than "prompts" and "completions", you should keep this to False.
num_generations (int, optional, defaults to 8) — Number of generations per prompt to sample. The effective batch size (num_processes * per_device_batch_size
gradient_accumulation_steps) must be evenly divisible by this value.
num_generations_eval (int or None, optional) — Number of generations to sample during evaluation. This allows using fewer generations during evaluation to save computation. If None, uses the value of num_generations.
max_completion_length (int or None, optional, defaults to 256) — Maximum length of the generated completion.
ds3_gather_for_generation (bool, optional, defaults to True) — This setting applies to DeepSpeed ZeRO-3. If enabled, the policy model weights are gathered for generation, improving generation speed. However, disabling this option allows training models that exceed the VRAM capacity of a single GPU, albeit at the cost of slower generation. Disabling this option is not compatible with vLLM generation.
shuffle_dataset (bool, optional, defaults to True) — Whether to shuffle the training dataset.
Parameters that control generation

generation_batch_size — (int, optional): Batch size to use for generation. If None, it defaults to the effective training batch size: per_device_train_batch_size * num_processes * steps_per_generation. In other words, there is one generation batch processed per optimization step. Mutually exclusive with steps_per_generation.
steps_per_generation — (int, optional): Number of steps per generation. If None, it defaults to gradient_accumulation_steps. Mutually exclusive with generation_batch_size.
temperature (float, defaults to 1.0) — Temperature for sampling. The higher the temperature, the more random the completions.
top_p (float, optional, defaults to 1.0) — Float that controls the cumulative probability of the top tokens to consider. Must be in (0, 1]. Set to 1.0 to consider all tokens.
top_k (int, optional) — Number of highest probability vocabulary tokens to keep for top-k-filtering. If None, top-k-filtering is disabled and all tokens are considered.
min_p (float, optional) — Minimum token probability, which will be scaled by the probability of the most likely token. It must be a value between 0.0 and 1.0. Typical values are in the 0.01-0.2 range.
generation_kwargs (dict[str, Any], optional) — Additional keyword arguments to pass to GenerationConfig (if using transformers) or SamplingParams (if using vLLM) when sampling completions. This can be used to further customize the generation behavior, such as setting suppress_tokens, num_beams, etc. If it contains keys that conflict with the other generation parameters (like min_p, top_p, etc.), they will override them.
chat_template_kwargs (dict[str, Any], optional) — Additional keyword arguments to pass to the apply_chat_template function when generating completions.
repetition_penalty (float, optional, defaults to 1.0) — Float that penalizes new tokens based on whether they appear in the prompt and the generated text so far. Values > 1.0 encourage the model to use new tokens, while values < 1.0 encourage the model to repeat tokens.
use_transformers_paged (bool, optional, defaults to False) — Whether to use the transformers paged implementation for generation. If set to True, the transformers paged implementation will be used for generation instead of the default padded implementation. This parameter is only effective when use_vllm is set to False.
cache_implementation (str, optional) — Implementation of the cache method for faster generation when use_vllm is set to False.
Parameters that control generation acceleration powered by vLLM

use_vllm (bool, optional, defaults to False) — Whether to use vLLM for generating completions. If set to True, the trainer will use vLLM for generation instead of the default model.generate(). Requires vllm to be installed.
vllm_mode (str, optional, defaults to "server") — Mode to use for vLLM integration when use_vllm is set to True. Must be one of "server" or "colocate".
"server": The trainer will send generation requests to a separate vLLM server. Make sure a TRL vLLM server is running (start with trl vllm-serve).
"colocate": vLLM will run in the same process and share the training GPUs. This avoids the need for a separate server but may cause resource contention with training.
vllm_model_impl (str, optional, defaults to "vllm") — Model implementation to use for vLLM. Must be one of "transformers" or "vllm". "transformers": Use the transformers backend for model implementation. "vllm": Use the vllm library for model implementation.
vllm_guided_decoding_regex (str, optional) — Regex for vLLM guided decoding. If None (default), guided decoding is disabled.
Parameters that control the vLLM server (only used when `vllm_mode` is `"server"`)

vllm_server_base_url (str, optional) — Base URL for the vLLM server (e.g., "http://localhost:8000"). If provided, vllm_server_host and vllm_server_port are ignored.
vllm_server_host (str, optional, defaults to "0.0.0.0") — Host of the vLLM server to connect to. Ignored if vllm_server_base_url is provided.
vllm_server_port (int, optional, defaults to 8000) — Port of the vLLM server to connect to. Ignored if vllm_server_base_url is provided.
vllm_server_timeout (float, optional, defaults to 240.0) — Total timeout duration in seconds to wait for the vLLM server to be up. If the server is not up after the timeout, a ConnectionError is raised.
Parameters that control colocated vLLM execution (only used when `vllm_mode` is `"colocate"`)

vllm_gpu_memory_utilization (float, optional, defaults to 0.3) — Control the GPU memory utilization for vLLM. This setting only applies when vllm_mode is set to "colocate". If you are using vllm_mode="server", this parameter must be passed separately when launching the vLLM server via the --vllm_gpu_memory_utilization flag.
vllm_max_model_length (int, optional, defaults to None) — Context window for vLLM. Set it to at least the maximum prompt length in the dataset plus max_completion_length; if omitted, it is inferred from the model config.
vllm_tensor_parallel_size (int, optional, defaults to 1) — Control the tensor parallel size for vLLM. This setting only applies when vllm_mode is set to "colocate". If you are using vllm_mode="server", this parameter must be passed separately when launching the vLLM server via the --vllm_tensor_parallel_size flag.
vllm_enable_sleep_mode (bool, optional, defaults to False) — Enable vLLM sleep mode to offload weights/cache during the optimizer step. Keeps GPU memory usage low, but waking the engine adds host–device transfer latency.
Parameters that control the training

beta (float, optional, defaults to 0.0) — KL coefficient. If 0.0 (default), the reference model is not loaded, reducing memory usage and improving training speed. DeepSeek-R1 incentivizes reasoning in LLMs through reinforcement learning use a value of 0.001.
num_iterations (int, optional, defaults to 1) — Number of iterations per batch (denoted as μ in the algorithm).
epsilon (float, optional, defaults to 0.2) — Epsilon value for clipping.
delta (float, optional) — Enables the upper clipping bound in two-sided GRPO loss when set to a float. If None (default), standard GRPO clipping is used. Recommended to be greater than 1 + ε when enabled. This method is introduced in the INTELLECT-2 tech report.
epsilon_high (float, optional) — Upper-bound epsilon value for clipping. If not specified, it defaults to the same value as the lower-bound specified in argument epsilon. Paper DAPO recommends 0.28. When used with loss_type='cispo', this corresponds to the ε_max param specified in the ScaleRL paper and the recommended value is 5.0.
sapo_temperature_neg (float, optional, defaults to 1.05) — Temperature for tokens with non-positive advantage scores used in the sapo loss function. This parameter is introduced in the Soft Adaptive Policy Optimization paper.
sapo_temperature_pos (float, optional, defaults to 1.0) — Temperature for tokens with positive advantage scores used in the sapo loss function. This parameter is introduced in the Soft Adaptive Policy Optimization paper.
importance_sampling_level (str, optional, defaults to "token") — Controls whether importance sampling ratios are computed at the "token" or "sequence" level. "token" keeps the raw per-token log-probability ratios (one weight per token). "sequence" averages the log-probability ratios across valid tokens to produce a single ratio per sequence. The GSPO paper shows that sequence-level sampling often yields more stable training and better alignment with sequence-level rewards.
reward_weights (list[float], optional) — Weights for each reward function. Must match the number of reward functions. If None, all rewards are weighted equally with weight 1.0.
scale_rewards (str or bool, optional, defaults to "group") — Specifies the scaling strategy for rewards. Supported values are:
True or "group" (default): rewards are scaled by the standard deviation within each group, ensuring unit variance within a group.
"batch": rewards are scaled by the standard deviation across the entire batch, as recommended in the PPO Lite paper.
False or "none": no scaling is applied. The Dr. GRPO paper recommends not scaling rewards, as scaling by the standard deviation introduces a question-level difficulty bias.
loss_type (str, optional, defaults to "dapo") — Specifies the loss formulation to use. Supported values are:
"grpo": Aggregates token-level losses by normalizing over sequence length. Not recommended due to length bias—this approach tends to prefer shorter completions with positive advantages and longer ones with negative advantages.
"dr_grpo": Aggregates token-level losses by normalizing with a global constant. This method was introduced in the Dr. GRPO paper to eliminate length bias. The value of the constant corresponds to max_completion_length.
"dapo" (default): Aggregates token-level losses by normalizing with the number of active token in the global accumulated batch. This method was introduced in the DAPO paper to eliminate length bias.
"bnpo": Aggregates token-level losses by normalizing with the number of active token in the local batch. Note that normalization is performed over the local batch only, so results may slightly vary depending on the local batch size, despite a constant effective batch size. When using per_device_train_batch_size==1, the loss is equivalent to the GRPO loss.
"cispo": Clips the importance sampling weights instead of the advantage scaled importance weights. The clipped weights are then multiplied with the advantages and policy model’s log probs. Individual token losses are aggregated by normalizing with the number of active tokens in the global accumulated batch. This method was introduced in the MiniMax-M1 paper.
"sapo": Soft Adaptive Policy Optimization loss, as introduced in the Soft Adaptive Policy Optimization paper. Replaces hard clipping with a smooth, temperature-controlled gate that adaptively attenuates off-policy updates while preserving useful learning signals.
mask_truncated_completions (bool, optional, defaults to False) — When enabled, truncated completions are excluded from the loss calculation, preventing them from being incorrectly penalized and introducing noise during training. According to the DAPO paper, this is a good practice for training stability.
sync_ref_model (bool, optional, defaults to False) — Whether to synchronize the reference model with the active model every ref_model_sync_steps steps, using the ref_model_mixup_alpha parameter. This synchronization originates from the TR-DPO paper.
ref_model_mixup_alpha (float, optional, defaults to 0.6) — α parameter from the TR-DPO paper, which controls the mix between the current policy and the previous reference policy during updates. The reference policy is updated according to the equation: π_ref = α * π_θ + (1 - α) * π_ref_prev. To use this parameter, you must set sync_ref_model=True.
ref_model_sync_steps (int, optional, defaults to 512) — τ parameter from the TR-DPO paper, which determines how frequently the current policy is synchronized with the reference policy. To use this parameter, you must set sync_ref_model=True.
top_entropy_quantile (float, optional, defaults to 1.0) — ρ parameter from Beyond the 80/20 Rule. Keeps in the policy loss term only the top-ρ quantile of tokens by entropy of the probability distribution at each sequence position, improving results. Range: [0.0-1.0]. A value of 0.0 masks all but the highest entropy token; 1.0 keeps all tokens. The paper recommends a value of 0.2. If used with mask_truncated_completions=True, only tokens from non-truncated completions are considered.
use_liger_loss (bool, optional) — Whether to use Liger loss.
Parameter use_liger_loss is deprecated and will be removed in version 0.28.0. Use use_liger_kernel instead.

vllm_importance_sampling_correction (bool, optional, defaults to True) — Whether to apply Importance Sampling (IS) to correct for the mismatch between vLLM completion logprobs and recomputed training logprobs. If set to False, no IS is applied regardless of vllm_importance_sampling_mode. When True, the selected mode determines how the IS ratios are computed and constrained.
vllm_importance_sampling_mode (str, optional, defaults to "sequence_mask") — Specifies how Importance Sampling is performed when vllm_importance_sampling_correction=True. Possible values are:
"token_truncate": Token-level truncated IS (default). Per-token ratios are clipped from above at C.
"token_mask": Token-level masked IS. Per-token ratios above C are set to zero.
"sequence_truncate": Sequence-level truncated IS. A single sequence ratio is clipped from above at C and applied to all tokens in the sequence.
"sequence_mask": Sequence-level masked IS. Sequences with ratios above C are masked out.
vllm_importance_sampling_cap (float, optional, defaults to 3.0) — Importance sampling cap C used by vllm_importance_sampling_mode. For *_truncate modes, importance ratios are clipped from above at C. For *_mask modes, ratios larger than C are set to zero.
use_bias_correction_kl (bool, optional, defaults to False) — Whether to use the unbiased KL divergence estimator with importance sampling correction. This corrects the KL divergence estimate by multiplying it with the importance sampling ratio. This is described in the DeepSeek-V3.2 paper.
Parameters that control the logging

log_completions (bool, optional, defaults to False) — Whether to log a sample of (prompt, completion) pairs every logging_steps steps. If rich is installed, it prints the sample. If wandb and/or trackio logging is enabled, it logs it to wandb and/or trackio.
num_completions_to_print (int, optional) — Number of completions to print with rich. If None, all completions are logged.
log_unique_prompts (bool, optional, defaults to False) — Whether to log unique prompts. If True, only unique prompts are logged. If False, all prompts are logged.
Deprecated arguments

max_prompt_length (bool, optional) —
Parameter max_prompt_length is deprecated and will be removed in version 0.28.0. You should instead filter your dataset before training to ensure that prompts do not exceed your desired length.

wandb_log_unique_prompts (bool, optional) —
Parameter wandb_log_unique_prompts is deprecated and will be removed in version 0.27.0. Use log_unique_prompts instead.

Configuration class for the GRPOTrainer.

This class includes only the parameters that are specific to GRPO training. For a full list of training arguments, please refer to the TrainingArguments documentation. Note that default values in this class may differ from those in TrainingArguments.

Using HfArgumentParser we can turn this class into argparse arguments that can be specified on the command line.